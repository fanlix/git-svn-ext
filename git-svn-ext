#!/usr/bin/env python

from commands import getoutput
import os
import re
import sys
import logging

logger = logging.getLogger()
console = logging.StreamHandler()
formatter = logging.Formatter('%(levelname)-8s %(message)s')
console.setFormatter(formatter)
logger.addHandler(console)
logger.level = logging.INFO

# This is so we can change directories but still have a reference
# to ourselves
git_svn_ext_fullpath = os.path.abspath(sys.argv[0])
externals_dir = ".git_externals"
excludes_file = ".git_external_excludes"

##################### Helper Methods #####################

def list_references():
    """List the references in the local repo.

    Return a tuple with the SHA1 of HEAD and a dictionary with the
    SHA1 of the references as keys and the reference name as value.
    """
    references = getoutput('git show-ref --head')
    HEAD_ref = None
    refs = {}
    for item in references.split('\n'):
        stuff = item.split()
        if len(stuff) == 2:
            (sha1, name) = stuff
            if name == 'HEAD':
                HEAD_ref = sha1
            refs[sha1] = name
    return HEAD_ref, refs


def commit_objects():
    """List commit objects in reverse chronological order.

    Return a dict with the SHA1 of the commits as keys and the SHA1 of
    the parents as values.
    """
    commit_list = getoutput('git rev-list --all --parents')
    commits = {}
    for item in commit_list.split('\n'):
        splitted_item = item.split()
        if len(splitted_item) != 2:
            commit = splitted_item[0]
            parent = None
        else:
            commit, parent = splitted_item
        commits[commit] = parent
    return commits


def find_svn_branch_name():
    """Return the reference name of the current remote branch."""
    head, references = list_references()
    commits = commit_objects()

    current_commit = head
    while current_commit:
        if current_commit in references:
            reference_name = references[current_commit]
            if ('remote' in reference_name or
                'trunk' in reference_name or
                'git-svn' in reference_name):
                logger.debug('Found remote: %s', reference_name)
                return reference_name
        # find the parent of the current commit
        # and make it the next commit to investigate
        if current_commit in commits:
            current_commit = commits[current_commit]
    return None


def find_uncommitted(svn_branch):
    """Given the name of the remote branch, show log of the commits."""

    # One line commit of uncommitted commits
    results = []
    output = getoutput('git log --pretty="format:%%h %%s" %s..HEAD' %
                       svn_branch)
    if output:
        results += output.split('\n')

    return results

def exit_if_not_toplevel():
    """exit if not run from the top level git directory"""
    toplevel_directory = getoutput("git rev-parse --show-cdup")

    if toplevel_directory != "":
        print "Error: not in toplevel directory"
        sys.exit(1)

def is_excluded(external):
    """return True if excluding this external"""

    if os.path.exists(excludes_file):
        for line in open(excludes_file).readlines():
            if re.search("^/%s$" % external, line):
                return True

    return False


def create_dir_if_not_exist(dir):
    """helper to create a directory if it doesn't exist"""
    if not os.path.exists(dir): os.mkdir(dir)


def do_link(external_dir, link_dir):
    """create the link to the external"""

    current_dir = os.getcwd()

    os.chdir(external_dir)

    # get relative back to git-svn root
    rel = getoutput("git rev-parse --show-cdup")

    link_name = os.path.basename(link_dir)

    # NOTE: the original used -f, so remove and recreate
    if os.path.exists(link_name): os.unlink(link_name)

    os.symlink(rel + externals_dir + os.sep + link_name, link_name)

    os.chdir(current_dir)

def append_line_if_not_included(filename, line):

    found = False
    for l in open(filename).readlines():
        if line == l.rstrip():
            found = True
            break

    if not found:
        fd = open(filename, "a")
        # TODO: do we need to have a newline to the end of the file
        # before appending?
        fd.write(line + "\n")
        fd.close()

def do_excludes(external_link):
    """add symlink to the git excludes path"""

    git_excludes_path=".git/info/exclude"
    append_line_if_not_included(git_excludes_path, externals_dir)
    append_line_if_not_included(git_excludes_path, external_link)

def run_command(command):
    """print out and run a command"""
    print command
    return os.system(command)

def do_clone(local_directory, remote_url, revision):
    """do the actual cloning"""

    # make sure the dir exists
    if not os.path.exists(externals_dir):
        return False

    (module, branch) = re.search("(.*)/(trunk|branch.*|tag.*)", remote_url).groups()

    if branch == remote_url:
        branch = ""

    current_dir1 = os.getcwd()

    os.chdir(externals_dir)

    # Default
    has_branches_tags = False

    # if we found references to branches and tags, clone them
    if module != remote_url:
        has_branches_tags = True

    # if we are cloning a subdirectory of a branch path, use the remote_url, and don't get tags/branch/trunk
    # ie: if it contains some of these, but does not end with it
    if re.search("trunk|tags|branch.*", remote_url):
        if not re.search("trunk$|tags$|branch.*$", remote_url):
            has_branches_tags = False
            module = remote_url

    # Try to figure out what the tags and branches portions are
    tags = "tags"
    brch = "branches"
    branchpath = branch.split("/")[0]
    if tags.count(branchpath): tags = branchpath
    if brch.count(branchpath): brch = branchpath

    # Format the revision argument
    rev_arg = ""
    if revision != "":
        rev_arg = "--revision BASE:" + revision

    # If the directory is alread there, update it
    if os.path.isdir(local_directory):
        current_dir2 = os.getcwd()
        os.chdir(local_directory)
        run_command("git svn fetch " + rev_arg)
        # -l skips fetching
        run_command("git svn rebase --local")
        os.chdir(current_dir2)
    # Otherwise, clone it
    else:

        if has_branches_tags:
            run_command("git svn clone %s %s -T trunk -b %s -t %s %s" % (rev_arg, module, brch, tags, local_directory))
        else:
            # URL does not contains any trunk, branches or tags part, so we dont need
            # additional options for git-svn
            run_command("git svn clone %s %s %s" % (rev_arg, module, local_directory))

    # If we have branches and tags, checkout that directory
    # careful, can blow aways changes!
    # remove trailing slash
    branch = re.sub("/$", "", branch)

    if branch != "" and has_branches_tags:
        current_dir3 = os.getcwd()
        os.chdir(local_directory)
        run_command("git reset --hard " + branch)
        os.chdir(current_dir3)

    os.chdir(current_dir1)

    return True

def get_svn_root_url():
    """Parse out the svn root to use with relative urls"""

    root = ""
    for line in getoutput("git svn info").split("\n"):
        matches = re.search("Repository Root: (.*)", line)

        if matches:
            root = matches.group(1)


    if root == "":
        print "Unable to determine repository root"
        sys.exit(1)

    return root

class SvnExternal:
    """Class to hold and manipulate data about an svn external"""

    def __init__(self, external_dir, local_dir, remote_url, revision):
        self.external_dir = external_dir
        self.local_dir    = local_dir
        self.remote_url   = remote_url
        self.revision     = revision

    @staticmethod
    def GetExternals():
        ret = []

        current_dir = ""
        for line in getoutput("git svn show-externals").split("\n"):

            current_dir_matches = re.search(r"# /(.*)", line)
            # format: current_dir/dir[@rev] [-r 123] dir
            # the ?P<name> syntax is to get the stuff by name
            re_current_dir = current_dir.replace("/", "\\/") # regular expression safe string
            # NOTE: the remote_url section is non-greedy so that @rev is matched correctly
            external_matches = re.search(r"/%s(?P<remote_url>.+?)(@(?P<rev1>\d+))? (-r\s*(?P<rev2>\d+) )?(?P<local_dir>.+)" % re_current_dir , line)

            if current_dir_matches:
                # save off the current dir
                current_dir = current_dir_matches.group(1)
                #print "Setting current_dir to: " + current_dir
                continue

            elif external_matches:

                external_info = external_matches.groupdict()

                # Check for relative url
                remote_url = external_info["remote_url"]
                # TODO: there are probably other external url types that we don't handle
                if remote_url.count("^"):
                    svn_root_url = get_svn_root_url()
                    svn_base = os.path.dirname(svn_root_url)
                    svn_path = os.path.basename(svn_root_url)
                    remote_url = remote_url.replace("^", svn_path)

                    # Normalize the path
                    remote_url = os.path.normpath(remote_url)

                    # Stick them back together
                    # had to split apart because normpath turns "//" into "/"
                    # maybe a better url parsing method would be better?
                    remote_url = svn_base + os.sep + remote_url

                local_dir = external_info["local_dir"]

                # Determine the revision (hopefully only 1 is specified)
                revision = ""
                if external_info["rev1"] != None:
                    revision = external_info["rev1"]
                elif external_info["rev2"] != None:
                    revision = external_info["rev2"]

                # Allow exclusion of externals
                if not is_excluded(local_dir):

                    # Honor env var to override url
                    if os.environ.has_key("USE_SSH"):
                        remote_url = re.sub("(http|https)", "svn+ssh", remote_url)

                # Add the info
                if remote_url != "":
                    ret.append(SvnExternal(current_dir, local_dir, remote_url, revision))

        return ret

    def local_storage(self):
        """Get the directory that this external will be cloned to"""

        # TODO/NOTE: it's possible to have 2 externals of the same name
        # in different directories
        return externals_dir + os.sep + self.local_dir

    def revision_arguments(self):
        """Format argumntes if there's a revision"""

        # Format the revision argument
        rev_arg = ""
        if self.revision != "":
            rev_arg = "--revision BASE:" + self.revision
        return rev_arg

# maybe have this go to the repo root automatically?
def get_externals_paths():
    """Get a list of paths to externals for the current dir"""

    results = []

    if os.path.isdir(externals_dir):
        for external in os.listdir(externals_dir):
            gitdir = os.path.join(externals_dir, external, ".git")
            if os.path.isdir(gitdir):
                results.append(os.path.dirname(gitdir))

    return results

########### sub-command handlers #############


def clone_handler(args):
    """clone all svn externals into .git_externals
    (warning: removes local changes and commits on subsequent runs)"""

    exit_if_not_toplevel()

    externals = SvnExternal.GetExternals()

    for external in externals:

        print "%s -> %s" % (external.local_dir, external.remote_url)

        dir = os.path.dirname(external.local_dir)

        # just create two dirs instead of pulling in mkpath
        create_dir_if_not_exist(externals_dir)
        create_dir_if_not_exist(os.path.join(externals_dir, dir))

        if not do_clone(external.local_dir, external.remote_url, external.revision):
            sys.exit(1)

        do_link(external.external_dir, external.local_dir)
        do_excludes(external.external_dir + external.local_dir)

# TODO: maybe clone should just do this instead?
# but clone can blow stuff away... (reset --hard)
def update_handler(args):
    """Updates all svn externals (git svn fetch[ --revision]/rebase --local)"""

    exit_if_not_toplevel()

    # Do show externals to get possible revisions
    # looks at svn server
    externals = SvnExternal.GetExternals()

    # get the externals dirs
    # looks at disk
    ext_paths = get_externals_paths()

    for ext in externals:
        ext_path = ext.local_storage()
        if ext_paths.count(ext_path):
            print ">>> " + ext_path
            current_dir = os.getcwd()
            os.chdir(ext_path)
            run_command("git svn fetch %s" % ext.revision_arguments())
            run_command("git svn rebase --local")

            os.chdir(current_dir)


# TODO: would it be nice to have a recursive option?
# otherwise, you have to run it from the root dir
def check_unpushed_handler(args):
    """Check if local git-svn checkout has unpushed commits"""

    status = getoutput('git status')
    if status.startswith('fatal'):
        print status
        sys.exit(1)
    svn_branch = find_svn_branch_name()
    if svn_branch is None:
        print "Warning: no svn branch found for: " + os.getcwd()
        sys.exit(1)
    logger.debug('Found branch: %s', svn_branch)

    commits = find_uncommitted(svn_branch)

    if len(commits) > 0:
        print 'Possible unpushed commits (against %s):' % svn_branch
        print "\n".join(commits)
    else:
        print 'No unpushed commits found.'

def check_handler(args):
    """run 'git status' and 'check-unpushed' for all externals"""

    exit_if_not_toplevel()

    for dir in get_externals_paths():

        current_dir = os.getcwd()
        os.chdir(dir)

        status = getoutput("git status")
        unpushed = getoutput(git_svn_ext_fullpath + " check-unpushed")
        if not re.search("clean", status) or not re.search("No unpushed", unpushed):
            print ">>>>>>>>>>>>>>>> %s <<<<<<<<<<<<<<<<" % dir
            # Run these again to get color output
            os.system("git status")
            os.system(git_svn_ext_fullpath + " check-unpushed")
            print "----------------------------------------"
        else:
            print dir + " is clean"

        os.chdir(current_dir)

def for_all_handler(args):
    """run a command against all externals
    (ie: git svn-ext for-all git grep 'whatever')"""

    command = " ".join(args)

    if command:
        for dir in get_externals_paths():

            current_dir = os.getcwd()
            os.chdir(dir)

            print ">>> %s: %s" % (dir, command)

            os.system(command)

            os.chdir(current_dir)

    else:
        usage()
        sys.exit(1)


class Handlers:
    """Register and dispatch handlers, as well as provide documentation"""
    def __init__(self):
        # keep ordering
        self.names = []
        self.handlers = {}

    def add(self, name, handler):
        self.names.append(name)
        self.handlers[name] = handler

    def get(self, name):
        if self.handlers.has_key(name):
            return self.handlers[name]
        else:
            return None

    def _aligned_name(self, name):
        """string of spaces to pad command to align text"""

        # find out how long the lines are so they can line up
        max_len = 0
        for n in self.names:
            if len(n) > max_len:
                max_len = len(n)

        return name + " " * (1 + max_len - len(name))

    def helptext(self):
        """get description of all the handlers"""

        ret = ""

        for n in self.names:
            ret += "  %s: %s\n" % (self._aligned_name(n), self.handlers[n].__doc__)

        return ret


# NOTE: this order is preserved for usage help text
handlers = Handlers()
handlers.add('clone',          clone_handler)
handlers.add('update',         update_handler)
handlers.add('check-unpushed', check_unpushed_handler)
handlers.add('check',          check_handler)
handlers.add('for-all',        for_all_handler)

def usage():
    """Descriptive text of all options"""
    print ""
    print "Usage: " + sys.argv[0] + " <sub command> [sub command args]"
    print ""
    print " sub commmands:"
    print handlers.helptext()
    print ""

if __name__ == '__main__':

    handler = None

    try:
        sub_command = sys.argv[1]
        handler = handlers.get(sub_command)

        if handler == None:
            raise "invalid subcommand"

    except:
        usage()
        sys.exit(1)

    args = []
    if len(sys.argv) > 2:
        args += sys.argv[2:]

    handler(args)

